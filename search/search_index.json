{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>This is a collection of notes that I have been writing for some time during my software engineer career. I use them on daily basis instead of using Google or StackOverflow as the same issue usually happens more than once.</p>"},{"location":"#topics","title":"Topics","text":"<ul> <li>go</li> </ul>"},{"location":"go/project-structure/","title":"Microservice project structure","text":"<p>I suggest to use the following project structure for any microservice which usually is deployed using container image on kubernetes, exposes its core logic through HTTP or gRPC transport layers and interacts with other services using a message broker, such as kafka.</p> <pre><code>root/\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 app\n\u251c\u2500\u2500 db/\n\u2502   \u2514\u2500\u2500 migrations\n\u251c\u2500\u2500 docker\n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 gen\n\u251c\u2500\u2500 internal\n\u2502   \u2514\u2500\u2500 app\n\u2502   \u2514\u2500\u2500 clients\n\u2502   \u2514\u2500\u2500 events\n\u2502   \u2514\u2500\u2500 pubsub\n\u2502   \u2514\u2500\u2500 server\n\u2502   \u2514\u2500\u2500 services\n\u2502   \u2514\u2500\u2500 store\n\u251c\u2500\u2500 k8s\n\u251c\u2500\u2500 pkg\n\u251c\u2500\u2500 scripts\n\u251c\u2500\u2500 templates\n\u2514\u2500\u2500 tools\n</code></pre>"},{"location":"go/project-structure/#root-directories","title":"Root directories","text":"<ul> <li><code>cmd</code> \u2013 has one or more subdirectories for the entrypoints of main applications. Subdirectories must have only one   file \u2013 <code>main.go</code>.</li> <li><code>db</code> \u2013 database related resource files should be stored here. Currently, it has only one subdirectory <code>migrations</code>   where all the migrations for Postgres are stored.</li> <li><code>docker</code> \u2013 is a collection of Dockerfiles.</li> <li><code>docs</code> \u2013 any documentation or specification file such as <code>openapi.yaml</code> should be put in this directory.</li> <li><code>gen</code> \u2013 most of the generated Go code is put here.</li> <li><code>internal</code> \u2013 is a place to put all the internal logic related code, that should not be imported by other modules. See   more about internal directory below.</li> <li><code>k8s</code> \u2013 is used to store kubernetes manifests.</li> <li><code>pkg</code> \u2013 the best place for generic utility libraries, for instance, for string manipulation. API clients to interact   with current service can be put here. Make sure that you don't break contracts during the updates without noticing   other developers whi relies on your public package. You can prefix all the packages inside the subdirectories   with <code>pkg</code> prefix to avoid any name collisions during the imports.</li> <li><code>scripts</code> \u2013 the only place to put Bash or Powershell scripts.</li> <li><code>templates</code> \u2013 is a special directory to put Go template files used for code generation.</li> <li><code>tools</code> \u2013 code generators or tools used during CI/CD and local development which are usually compiled to the   executable or run using <code>go run</code> command. Each tool should have its own subdirectory.</li> </ul>"},{"location":"go/project-structure/#internal-directory","title":"Internal directory","text":"<p><code>internal</code> directory has 5 mandatory subdirectories:</p> <ul> <li><code>app</code> \u2013 contains the configuration structs for the application, the global constants and app-specific functions.   As this package can be imported from any other internal package I recommend to avoid import any internal package from   app package, to avoid possible cyclic dependencies.</li> <li><code>events</code> \u2013 any event-sourcing code should be placed in this directory and has its own subdirectory based on its   domain. For instance, <code>events/user</code> or <code>events/order</code>. Each subdirectory may have event structs, event handlers   and event publishers. All the code should be implementation agnostic.</li> <li><code>pubusb</code> \u2013 the directory where you should put the implementation of event-sourcing code, for example, kafka producers   and consumers.</li> <li><code>server</code> \u2013 transport layer code that communicates with core services are placed here. The application might have   multiple transports: HTTP, gRPC, SOAP. </li> <li><code>services</code> \u2013 contains all the Services of the application. Service is an abstract used to encapsulate the logic of a   single domain module. Examples: <code>UserService</code>, <code>OrderService</code>, <code>CartService</code>. Every services should have its own   subdirectory and suffixed with <code>svc</code> so <code>UserService</code> will be placed in <code>usersvc</code>, and the package name should be the   same. The suffix is added to avoid name collision with core logic module that stores structs and methods for domain.</li> <li><code>clients</code> \u2013 if the application is reliant on 3rd party services, and they are part of the domain level, then we can    put them in this subdirectory adding the suffix <code>client</code> or <code>cnt</code>.  </li> <li><code>store</code> \u2013 contains the implementation of Stores used in Services and EventHandlers or EventPublisher. The   implementations are grouped by the implementation provider, for example, Postgres.</li> </ul> <p>We mentioned the core logic code that Services rely on. That code is split into domains and each one should have its own subdirectory, which is also stored in the <code>internal</code> package. For example:</p> <ul> <li><code>user</code> \u2013 it may contain the structs such as <code>User</code>, <code>UserDetail</code> etc.</li> <li><code>order</code> \u2013 may contain all the core logic structs and methods related to the order domain.</li> </ul>"},{"location":"go/project-structure/#dependency-structure","title":"Dependency structure","text":"<p>On the image below you can the relationship between all those packages we talked above. Every package can rely on any  package which is below the former. </p> <p></p>"},{"location":"go/testing/","title":"Testing","text":""},{"location":"go/testing/#database-layer-testing","title":"Database layer testing","text":"<p>Every application has Store/Database layer which mostly consists of CRUD operations. There are some tips on how to write those test and what to test.</p> <p>Quick tips:</p> <ul> <li>Don't mock your database. Use dockertest.</li> <li>Test your migrations.</li> <li>Run your CRUD operations more than once, run 1000 times.</li> <li>Use fake and random data. Library such as gaofakeit helps you with that.</li> </ul> <p>Let's discuss every point mentioned above.</p> <p>Mocks</p> <p>You are testing your database layer, which means you are testing your implementation and not some abstract layer. Mocks are far away from a real Postgres or MySQL database. Testing against real database helps you to reveal some bugs before deploying your application to your real environment. Creating a new docker image for testing takes a few seconds, so don't be afraid of it.</p> <p>Migrations</p> <p>If your migrations are shipped with an application, test the migrations by calling <code>up</code> and <code>down</code> twice. It will help you avoid silly mistakes.</p> <p>1000 times</p> <p>During the tests create/read/update/delete more than once to catch deadlocks, avoid leaky resources and find some hidden bugs. For example, the method that should return only one record, returns more than one, or deleting one record in reality deletes more than one.</p> <p>Fake data</p> <p>Imagine that you mistakenly used <code>int8</code> in your database, but you are trying to save <code>int32</code> instead. If you use a constant value during the tests, you probably won't find the issue. Therefore, using some random data might help you to discover those problems during the tests.</p>"},{"location":"go/testing/#event-driven-applications-testing","title":"Event-driven applications testing","text":"<p>You definitely have a part of some application that listens for some events incoming from a message broker and writes them to the database. Our tests should cover a few things:</p> <ul> <li>All the valid events were received successfully.</li> <li>All the data from events was mapped correctly and saved to DB.</li> <li>Invalid data was rejected and moved somewhere else.</li> </ul> <p>Counter</p> <p>Don't use <code>time.Sleep</code> and wait for a constant time until all the events were digested. On slow machines it might take longer and the test will fail. On faster machines you are wasting time. I suggest to have a custom counter injected into your <code>Subscriber/Listener</code> object, and read it every few seconds until all the event were drained. After that fetch all the saved records from the database and check for equality with sent events. This strategy also helps to count the number of invalid events.</p> <p>Containers</p> <p>Use <code>dockertest</code> or similar library to spin up the containers programmatically during the tests. Don't try to mock <code>kafka</code> or any other message broker. Creating <code>kafka</code> container for tests might be very slow and consume a lot of CPU and RAM, so I would suggest to use something which is Kafka API compatible, e.g. redpanda. The latter doesn't need zookeeper, and it starts much faster than kafka.</p>"}]}